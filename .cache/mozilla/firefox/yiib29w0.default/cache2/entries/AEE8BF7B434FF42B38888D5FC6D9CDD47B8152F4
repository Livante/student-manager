// This file is part of Leaflet.Geodesic.
// Copyright (C) 2014  Henry Thasler
// based on code by Chris Veness Copyright (C) 2014 https://github.com/chrisveness/geodesy
// 
// Leaflet.Geodesic is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Leaflet.Geodesic is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Leaflet.Geodesic.  If not, see <http://www.gnu.org/licenses/>.



/** Extend Number object with method to convert numeric degrees to radians */
if (typeof Number.prototype.toRadians == 'undefined') {
    Number.prototype.toRadians = function() { return this * Math.PI / 180; }
}

/** Extend Number object with method to convert radians to numeric (signed) degrees */
if (typeof Number.prototype.toDegrees == 'undefined') {
    Number.prototype.toDegrees = function() { return this * 180 / Math.PI; }
}

//var INTERSECT_LNG = 179.999;	// Lng used for intersection and wrap around on map edges 
var INTERSECT_LNG = 180;    // Lng used for intersection and wrap around on map edges 

L.Geodesic = L.Polyline.extend({
    options: {
	color:'blue',
	steps: 10,
	dash: 1,
        wrap: true
    },  
  
    initialize: function (latlngs, options) {
      this.options = this._merge_options(this.options, options);
      this.datum = {};
      this.datum.ellipsoid = { a: 6378137,     b: 6356752.3142,   f: 1/298.257223563 };	 // WGS-84
      this._latlngs = (this.options.dash<1)?this._generate_GeodesicDashed(latlngs):this._generate_Geodesic(latlngs);
      L.Polyline.prototype.initialize.call(this, this._latlngs, this.options);    
    },
  
    setLatLngs: function (latlngs) {
      this._latlngs = (this.options.dash<1)?this._generate_GeodesicDashed(latlngs):this._generate_Geodesic(latlngs);
      L.Polyline.prototype.setLatLngs.call(this, this._latlngs);
    },

    /**
    * Calculates some statistic values of current geodesic multipolyline
    * @returns (Object} Object with several properties (e.g. overall distance)
    */
    getStats: function () {
      var obj={	distance: 0,
		points: 0,
		polygons: this._latlngs.length
	      }, poly, points;
	    
      for(poly=0; poly<this._latlngs.length;poly++) {
	obj.points+=this._latlngs[poly].length;
	for(points=0;points<(this._latlngs[poly].length-1);points++) {
	  obj.distance += this._vincenty_inverse(this._latlngs[poly][points], this._latlngs[poly][points+1]).distance;
	}
      }
      return obj;
    },
    
    /**
    * Creates a great circle. Replaces all current lines.
    * @param {Object} center - geographic position
    * @param {number} radius - radius of the circle in meters
    */
    createCircle: function (center, radius) {
      var _geo = [], _geocnt=0;
      var prev = {lat:0, lng:0, brg:0};//new L.LatLng(0, 0);
      var s;
      
      _geo[_geocnt] = [];
      
      var direct = this._vincenty_direct(L.latLng(center), 0, radius, this.options.wrap);
      prev = L.latLng(direct.lat, direct.lng);
      _geo[_geocnt].push(prev);
      for(s=1; s<=this.options.steps; ) {
	direct = this._vincenty_direct(L.latLng(center), 360/this.options.steps*s, radius, this.options.wrap);
	var gp = L.latLng(direct.lat, direct.lng);
	if(Math.abs(gp.lng-prev.lng) > 180) {
	  var inverse = this._vincenty_inverse(prev, gp);
	  var sec = this._intersection(prev, inverse.initialBearing, {lat: -89, lng:((gp.lng-prev.lng)>0)?-INTERSECT_LNG:INTERSECT_LNG}, 0);
	  if(sec) {
	    _geo[_geocnt].push(L.latLng(sec.lat, sec.lng));
	    _geocnt++;
	    _geo[_geocnt] = [];
	    prev = L.latLng(sec.lat, -sec.lng);
	    _geo[_geocnt].push(prev);
	  }
	  else {
	    _geocnt++;
	    _geo[_geocnt] = [];
	    _geo[_geocnt].push(gp);
	    prev = gp;
	    s++;
	  }
	}
	else {
	  _geo[_geocnt].push(gp);
	  prev = gp;
	  s++;
	}
      }

      this._latlngs = _geo;
      L.Polyline.prototype.setLatLngs.call(this, this._latlngs);
    },
    
    /**
    * Creates a geodesic Polyline from given coordinates
    * @param {Object} latlngs - One or more polylines as an array. See Leaflet doc about Polyline 
    * @returns (Object} An array of arrays of geographical points.
    */
    _generate_Geodesic: function (latlngs) {
      var _geo = [], _geocnt=0, s, poly, points;
//      _geo = latlngs;		// bypass

      for(poly=0; poly<latlngs.length;poly++) {
	_geo[_geocnt] = [];
	for(points=0;points<(latlngs[poly].length-1);points++) {
	  var inverse = this._vincenty_inverse(L.latLng(latlngs[poly][points]), L.latLng(latlngs[poly][points+1]));
	  var prev = L.latLng(latlngs[poly][points]);
	  _geo[_geocnt].push(prev);
	  for(s=1; s<=this.options.steps; ) {
	    var direct = this._vincenty_direct(L.latLng(latlngs[poly][points]), inverse.initialBearing, inverse.distance/this.options.steps*s, this.options.wrap);
	    var gp = L.latLng(direct.lat, direct.lng);
	    if(Math.abs(gp.lng-prev.lng) > 180) {
	      var sec = this._intersection(L.latLng(latlngs[poly][points]), inverse.initialBearing, {lat: -89, lng:((gp.lng-prev.lng)>0)?-INTERSECT_LNG:INTERSECT_LNG}, 0);
	      if(sec) {
		_geo[_geocnt].push(L.latLng(sec.lat, sec.lng));
		_geocnt++;
		_geo[_geocnt] = [];
		prev = L.latLng(sec.lat, -sec.lng);
		_geo[_geocnt].push(prev);
	      }
	      else {
		_geocnt++;
		_geo[_geocnt] = [];
		_geo[_geocnt].push(gp);
		prev = gp;
		s++;
	      }
	    }
	    else {
	      _geo[_geocnt].push(gp);
	      prev = gp;
	      s++;
	    }
	  }
	}
	_geocnt++;
      }
      return _geo;
    },
    
    
    /**
    * Creates a dashed geodesic Polyline from given coordinates - under work
    * @param {Object} latlngs - One or more polylines as an array. See Leaflet doc about Polyline 
    * @returns (Object} An array of arrays of geographical points.
    */
    _generate_GeodesicDashed: function (latlngs) {
      var _geo = [], _geocnt=0, s, poly, points;
//      _geo = latlngs;		// bypass

      for(poly=0; poly<latlngs.length;poly++) {
	_geo[_geocnt] = [];
	for(points=0;points<(latlngs[poly].length-1);points++) {
	  var inverse = this._vincenty_inverse(L.latLng(latlngs[poly][points]), L.latLng(latlngs[poly][points+1]));
	  var prev = L.latLng(latlngs[poly][points]);
	  _geo[_geocnt].push(prev);
	  for(s=1; s<=this.options.steps; ) {
	    var direct = this._vincenty_direct(L.latLng(latlngs[poly][points]), inverse.initialBearing, inverse.distance/this.options.steps*s-inverse.distance/this.options.steps*(1-this.options.dash), this.options.wrap);
	    var gp = L.latLng(direct.lat, direct.lng);
	    if(Math.abs(gp.lng-prev.lng) > 180) {
	      var sec = this._intersection(L.latLng(latlngs[poly][points]), inverse.initialBearing, {lat: -89, lng:((gp.lng-prev.lng)>0)?-INTERSECT_LNG:INTERSECT_LNG}, 0);
	      if(sec) {
		_geo[_geocnt].push(L.latLng(sec.lat, sec.lng));
		_geocnt++;
		_geo[_geocnt] = [];
		prev = L.latLng(sec.lat, -sec.lng);
		_geo[_geocnt].push(prev);
	      }
	      else {
		_geocnt++;
		_geo[_geocnt] = [];
		_geo[_geocnt].push(gp);
		prev = gp;
		s++;
	      }
	    }
	    else {
	      _geo[_geocnt].push(gp);
	      _geocnt++;
	      var direct2 = this._vincenty_direct(L.latLng(latlngs[poly][points]), inverse.initialBearing, inverse.distance/this.options.steps*s, this.options.wrap);
	      _geo[_geocnt] = [];
	      _geo[_geocnt].push(L.latLng(direct2.lat, direct2.lng));
	      s++;
	    }
	  }
	}
	_geocnt++;
      }
      return _geo;
    },    
    
    
    /**
    * Vincenty direct calculation.
    * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)
    *
    * @private
    * @param {number} initialBearing - Initial bearing in degrees from north.
    * @param {number} distance - Distance along bearing in metres.
    * @returns (Object} Object including point (destination point), finalBearing.
    */
    
    _vincenty_direct : function (p1, initialBearing, distance, wrap) {
      var Ï†1 = p1.lat.toRadians(), Î»1 = p1.lng.toRadians();
      var Î±1 = initialBearing.toRadians();
      var s = distance;

      var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;

      var sinÎ±1 = Math.sin(Î±1);
      var cosÎ±1 = Math.cos(Î±1);

      var tanU1 = (1-f) * Math.tan(Ï†1), cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1 * cosU1;
      var Ïƒ1 = Math.atan2(tanU1, cosÎ±1);
      var sinÎ± = cosU1 * sinÎ±1;
      var cosSqÎ± = 1 - sinÎ±*sinÎ±;
      var uSq = cosSqÎ± * (a*a - b*b) / (b*b);
      var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
      var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));

      var Ïƒ = s / (b*A), ÏƒÊ¹, iterations = 0;
      do {
	  var cos2ÏƒM = Math.cos(2*Ïƒ1 + Ïƒ);
	  var sinÏƒ = Math.sin(Ïƒ);
	  var cosÏƒ = Math.cos(Ïƒ);
	  var Î”Ïƒ = B*sinÏƒ*(cos2ÏƒM+B/4*(cosÏƒ*(-1+2*cos2ÏƒM*cos2ÏƒM)-
	      B/6*cos2ÏƒM*(-3+4*sinÏƒ*sinÏƒ)*(-3+4*cos2ÏƒM*cos2ÏƒM)));
	  ÏƒÊ¹ = Ïƒ;
	  Ïƒ = s / (b*A) + Î”Ïƒ;
      } while (Math.abs(Ïƒ-ÏƒÊ¹) > 1e-12 && ++iterations);

      var x = sinU1*sinÏƒ - cosU1*cosÏƒ*cosÎ±1;
      var Ï†2 = Math.atan2(sinU1*cosÏƒ + cosU1*sinÏƒ*cosÎ±1, (1-f)*Math.sqrt(sinÎ±*sinÎ± + x*x));
      var Î» = Math.atan2(sinÏƒ*sinÎ±1, cosU1*cosÏƒ - sinU1*sinÏƒ*cosÎ±1);
      var C = f/16*cosSqÎ±*(4+f*(4-3*cosSqÎ±));
      var L = Î» - (1-C) * f * sinÎ± *
	  (Ïƒ + C*sinÏƒ*(cos2ÏƒM+C*cosÏƒ*(-1+2*cos2ÏƒM*cos2ÏƒM)));
          
      if(wrap)
        var Î»2 = (Î»1+L+3*Math.PI)%(2*Math.PI) - Math.PI; // normalise to -180...+180
      else
        var Î»2 = (Î»1+L); // do not normalize

      var revAz = Math.atan2(sinÎ±, -x);

      return {lat: Ï†2.toDegrees(), 
	      lng: Î»2.toDegrees(),
	      finalBearing: revAz.toDegrees() 
      };
    },
    
    /**
    * Vincenty inverse calculation.
    * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)
    *
    * @private
    * @param {LatLng} p1 - Latitude/longitude of start point.
    * @param {LatLng} p2 - Latitude/longitude of destination point.
    * @returns {Object} Object including distance, initialBearing, finalBearing.
    * @throws {Error} If formula failed to converge.
    */    
    _vincenty_inverse: function (p1, p2) {
      var Ï†1 = p1.lat.toRadians(), Î»1 = p1.lng.toRadians();
      var Ï†2 = p2.lat.toRadians(), Î»2 = p2.lng.toRadians();

      var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;

      var L = Î»2 - Î»1;
      var tanU1 = (1-f) * Math.tan(Ï†1), cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1 * cosU1;
      var tanU2 = (1-f) * Math.tan(Ï†2), cosU2 = 1 / Math.sqrt((1 + tanU2*tanU2)), sinU2 = tanU2 * cosU2;

      var Î» = L, Î»Ê¹, iterations = 0;
      do {
	  var sinÎ» = Math.sin(Î»), cosÎ» = Math.cos(Î»);
	  var sinSqÏƒ = (cosU2*sinÎ») * (cosU2*sinÎ») + (cosU1*sinU2-sinU1*cosU2*cosÎ») * (cosU1*sinU2-sinU1*cosU2*cosÎ»);
	  var sinÏƒ = Math.sqrt(sinSqÏƒ);
	  if (sinÏƒ==0) return 0;  // co-incident points
	  var cosÏƒ = sinU1*sinU2 + cosU1*cosU2*cosÎ»;
	  var Ïƒ = Math.atan2(sinÏƒ, cosÏƒ);
	  var sinÎ± = cosU1 * cosU2 * sinÎ» / sinÏƒ;
	  var cosSqÎ± = 1 - sinÎ±*sinÎ±;
	  var cos2ÏƒM = cosÏƒ - 2*sinU1*sinU2/cosSqÎ±;
	  if (isNaN(cos2ÏƒM)) cos2ÏƒM = 0;  // equatorial line: cosSqÎ±=0 (Â§6)
	  var C = f/16*cosSqÎ±*(4+f*(4-3*cosSqÎ±));
	  Î»Ê¹ = Î»;
	  Î» = L + (1-C) * f * sinÎ± * (Ïƒ + C*sinÏƒ*(cos2ÏƒM+C*cosÏƒ*(-1+2*cos2ÏƒM*cos2ÏƒM)));
      } while (Math.abs(Î»-Î»Ê¹) > 1e-12 && ++iterations<100);
      if (iterations>=100) {
	console.log('Formula failed to converge. Altering target position.')
	return this._vincenty_inverse(p1, {lat: p2.lat, lng:p2.lng-0.01})
//	throw new Error('Formula failed to converge');
      }

      var uSq = cosSqÎ± * (a*a - b*b) / (b*b);
      var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
      var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
      var Î”Ïƒ = B*sinÏƒ*(cos2ÏƒM+B/4*(cosÏƒ*(-1+2*cos2ÏƒM*cos2ÏƒM)-
	  B/6*cos2ÏƒM*(-3+4*sinÏƒ*sinÏƒ)*(-3+4*cos2ÏƒM*cos2ÏƒM)));

      var s = b*A*(Ïƒ-Î”Ïƒ);

      var fwdAz = Math.atan2(cosU2*sinÎ»,  cosU1*sinU2-sinU1*cosU2*cosÎ»);
      var revAz = Math.atan2(cosU1*sinÎ», -sinU1*cosU2+cosU1*sinU2*cosÎ»);

      s = Number(s.toFixed(3)); // round to 1mm precision
      return { distance: s, initialBearing: fwdAz.toDegrees(), finalBearing: revAz.toDegrees() };
    },
    

    /**
    * Returns the point of intersection of two paths defined by point and bearing.
    * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)
    *
    * @param {LatLon} p1 - First point.
    * @param {number} brng1 - Initial bearing from first point.
    * @param {LatLon} p2 - Second point.
    * @param {number} brng2 - Initial bearing from second point.
    * @returns {Object} containing lat/lng information of intersection.
    *
    * @example
    * var p1 = LatLon(51.8853, 0.2545), brng1 = 108.55;
    * var p2 = LatLon(49.0034, 2.5735), brng2 = 32.44;
    * var pInt = LatLon.intersection(p1, brng1, p2, brng2); // pInt.toString(): 50.9078Â°N, 4.5084Â°E
    */
    _intersection : function(p1, brng1, p2, brng2) {
    // see http://williams.best.vwh.net/avform.htm#Intersection

      var Ï†1 = p1.lat.toRadians(), Î»1 = p1.lng.toRadians();
      var Ï†2 = p2.lat.toRadians(), Î»2 = p2.lng.toRadians();
      var Î¸13 = Number(brng1).toRadians(), Î¸23 = Number(brng2).toRadians();
      var Î”Ï† = Ï†2-Ï†1, Î”Î» = Î»2-Î»1;

      var Î´12 = 2*Math.asin( Math.sqrt( Math.sin(Î”Ï†/2)*Math.sin(Î”Ï†/2) +
	  Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)*Math.sin(Î”Î»/2) ) );
      if (Î´12 == 0) return null;

      // initial/final bearings between points
      var Î¸1 = Math.acos( ( Math.sin(Ï†2) - Math.sin(Ï†1)*Math.cos(Î´12) ) /
			  ( Math.sin(Î´12)*Math.cos(Ï†1) ) );
      if (isNaN(Î¸1)) Î¸1 = 0; // protect against rounding
      var Î¸2 = Math.acos( ( Math.sin(Ï†1) - Math.sin(Ï†2)*Math.cos(Î´12) ) /
			  ( Math.sin(Î´12)*Math.cos(Ï†2) ) );

      if (Math.sin(Î»2-Î»1) > 0) {
	  var Î¸12 = Î¸1;
	  var Î¸21 = 2*Math.PI - Î¸2;
      } else {
	  var Î¸12 = 2*Math.PI - Î¸1;
	  var Î¸21 = Î¸2;
      }

      var Î±1 = (Î¸13 - Î¸12 + Math.PI) % (2*Math.PI) - Math.PI; // angle 2-1-3
      var Î±2 = (Î¸21 - Î¸23 + Math.PI) % (2*Math.PI) - Math.PI; // angle 1-2-3

      if (Math.sin(Î±1)==0 && Math.sin(Î±2)==0) return null; // infinite intersections
      if (Math.sin(Î±1)*Math.sin(Î±2) < 0) return null; // ambiguous intersection

      //Î±1 = Math.abs(Î±1);
      //Î±2 = Math.abs(Î±2);
      // ... Ed Williams takes abs of Î±1/Î±2, but seems to break calculation?

      var Î±3 = Math.acos( -Math.cos(Î±1)*Math.cos(Î±2) +
			  Math.sin(Î±1)*Math.sin(Î±2)*Math.cos(Î´12) );
      var Î´13 = Math.atan2( Math.sin(Î´12)*Math.sin(Î±1)*Math.sin(Î±2),
			    Math.cos(Î±2)+Math.cos(Î±1)*Math.cos(Î±3) )
      var Ï†3 = Math.asin( Math.sin(Ï†1)*Math.cos(Î´13) +
			  Math.cos(Ï†1)*Math.sin(Î´13)*Math.cos(Î¸13) );
      var Î”Î»13 = Math.atan2( Math.sin(Î¸13)*Math.sin(Î´13)*Math.cos(Ï†1),
			    Math.cos(Î´13)-Math.sin(Ï†1)*Math.sin(Ï†3) );
      var Î»3 = Î»1 + Î”Î»13;
      Î»3 = (Î»3+3*Math.PI) % (2*Math.PI) - Math.PI; // normalise to -180..+180Âº

      return {lat: Ï†3.toDegrees(), 
	      lng: Î»3.toDegrees()
      };
    },    
    
  /**
  * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
  * @param obj1
  * @param obj2
  * @returns obj3 a new object based on obj1 and obj2
  */
    _merge_options: function(obj1,obj2){
      var obj3 = {};
      for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
      for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
      return obj3;
    }
});

L.geodesic = function(latlngs, options) {
    return new L.Geodesic(latlngs, options);
};

// Hook into L.GeoJSON.geometryToLayer and add geodesic support
(function (){
    var orig_L_GeoJSON_geometryToLayer = L.GeoJSON.geometryToLayer;
    L.GeoJSON.geometryToLayer = function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
        if (geojson.properties && geojson.properties.geodesic){
            var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                coords = geometry.coordinates, props = geojson.properties, latlngs;
            coordsToLatLng = coordsToLatLng || this.coordsToLatLng;
            if (props.geodesic_steps) vectorOptions = L.extend({steps: props.geodesic_steps}, vectorOptions);
            if (props.geodesic_wrap) vectorOptions = L.extend({wrap: props.geodesic_wrap}, vectorOptions);
            switch (geometry.type) {
                case 'LineString':
                    latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
                    return new L.Geodesic([latlngs], vectorOptions);
                case 'MultiLineString':
                    latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                    return new L.Geodesic(latlngs, vectorOptions);
                default:
                    console.log('Not yet supported drawing GeoJSON ' + geometry.type + ' as a geodesic: Drawing as non-geodesic.')
            }
        }
        return orig_L_GeoJSON_geometryToLayer.apply(this, arguments);
    }
})();
+WYáÃd      \œfÀ\œfÀ@1i\\¥¡@   2    :https://distanta.ro/temp/js/Leaflet.Geodesic.js?9 necko:classified 1 strongly-framed 1 security-info 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 request-method GET response-head HTTP/1.1 200 OK
Date: Thu, 28 Mar 2019 06:16:32 GMT
Server: Apache
Last-Modified: Sun, 26 Aug 2018 13:11:08 GMT
Accept-Ranges: bytes
Content-Length: 17406
Content-Type: application/javascript
 original-response-headers Date: Thu, 28 Mar 2019 06:16:32 GMT
Server: Apache
Last-Modified: Sun, 26 Aug 2018 13:11:08 GMT
Accept-Ranges: bytes
Content-Length: 17406
Keep-Alive: timeout=5, max=94
Connection: Keep-Alive
Content-Type: application/javascript
 uncompressed-len 0 net-response-time-onstart 49 net-response-time-onstop 49   Cþ